/* ファイル関係 */

#include "bootpack.h"
#include <stdio.h>
#include <string.h>

/**
 * ディスクイメージ内のFATの圧縮をとく
 */
void file_readfat(int *fat, unsigned char *img)
{
	int i, j = 0;
	for (i = 0; i < 2880; i += 2) {
		fat[i + 0] = (img[j + 0]      | img[j + 1] << 8) & 0xfff;
		fat[i + 1] = (img[j + 1] >> 4 | img[j + 2] << 4) & 0xfff;
		j += 3;
	}
	return;
}

/**
 * ファイルを読み込む
 */
void file_loadfile(int clustno, int size, char *buf, int *fat, char *img)
{
	int i;
	for (;;) {
		if (size <= 512) {
			for (i = 0; i < size; i++) {
				buf[i] = img[clustno * 512 + i];
			}
			break;
		}
		for (i = 0; i < 512; i++) {
			buf[i] = img[clustno * 512 + i];
		}
		size -= 512;
		buf += 512;
		clustno = fat[clustno];
	}
	return;
}

/**
 * search file in fileinfo using given name
 */
struct FILEINFO *file_search(char *name, struct FILEINFO *finfo, int max)
{
	int i, j;
	char s[12];
	for (j = 0; j < 11; j++) {
		s[j] = ' ';
	}
	j = 0;
	for (i = 0; name[i] != 0; i++) {
		if (j >= 11) { return 0; /* 見つからなかった */ }
		if (name[i] == '.' && j <= 8) {
			j = 8;
		} else {
			s[j] = name[i];
			if ('a' <= s[j] && s[j] <= 'z') {
				/* 小文字は大文字に直す */
				s[j] -= 0x20;
			}
			j++;
		}
	}
	for (i = 0; i < max; ) {
		if (finfo->name[0] == 0x00) {
			break;
		}
		if ((finfo[i].type & 0x18) == 0) {
			for (j = 0; j < 11; j++) {
				if (finfo[i].name[j] != s[j]) {
					goto next;
				}
			}
			return finfo + i; /* ファイルが見つかった */
		}
		next:
		i++;
	}
	return 0; /* 見つからなかった */
}

/**
 * search my file in my filesystem using name.
 * [TASK]
 * dinfo内のディレクトリファイルを探し出すためには、この関数の
 * アルゴリズムを書きなおす必要がある！
 * @name: Ex. "hoge.txt", "foo.hrb"
 */
struct MYFILEINFO *myfinfo_search(char *name, struct MYDIRINFO *dinfo, int max)
{
	int i, j;
	char s[12];
	for (j = 0; j < 11; j++) {
		s[j] = ' ';
	}
	j = 0;
	for (i = 0; name[i] != 0; i++) {
		if (j >= 11) { return 0; /* 見つからなかった */ }
		if (name[i] == '.' && j <= 8) {
			j = 8;
		} else {
			s[j] = name[i];
			if ('a' <= s[j] && s[j] <= 'z') {
				/* 小文字は大文字に直す */
				s[j] -= 'a'-'A';
			}
			j++;
		}
	}

	for (i = 0; i < max; ) {
		// ファイル名が無い場合、これ以上先にファイルがないので処理を終了させる。
		if (dinfo->finfo[i].name[0] == 0x00) {
			break;
		}

		/* ファイル名がある場合, finfoのfiletypeの識別をする */
		/* finfoがファイルの場合(今は２種類しかない) */
		if (dinfo->finfo[i].type == 0x20) {
			for (j = 0; j < 11; j++) {
				if (dinfo->finfo[i].name[j] != s[j]) {
					goto next;
				}
			}
			return dinfo->finfo + i; /* ファイルが見つかった */

			/* finfoがディレクトリの場合 */
		}else if(dinfo->finfo[i].type == 0x10){
			// ディレクトリは拡張子がないのでファイル名だけ比較する
			for (j = 0; j < 8; j++) {
				if (dinfo->finfo[i].name[j] != s[j]) {
					goto next;
				}
			}
			return dinfo->finfo + i; /* ディレクトリが見つかった */
		}
		next:
		i++;
	}
	return 0; /* 見つからなかった */
}

/**
 * load file
 */
char *file_loadfile2(int clustno, int *psize, int *fat)
{
	int size = *psize, size2;
	struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;
	char *buf, *buf2;
	buf = (char *) memman_alloc_4k(memman, size);
	file_loadfile(clustno, size, buf, fat, (char *) (ADR_DISKIMG + 0x003e00));
	if (size >= 17) {
		size2 = tek_getsize(buf);
		if (size2 > 0) {	/* tek圧縮がかかっていた */
			buf2 = (char *) memman_alloc_4k(memman, size2);
			tek_decomp(buf, buf2, size2);
			memman_free_4k(memman, (int) buf, size);
			buf = buf2;
			*psize = size2;
		}
	}
	return buf;
}


/**
 * ファイル情報管理領域から、使われていないディレクトリ空間を探し、初期化したのち、その場所を返す
 */
struct MYDIRINFO *get_newdinfo(){
	char s[50];
	struct MYDIRINFO *dinfo = (struct MYDIRINFO *)ROOT_DIR_ADDR;
	struct MYDIRINFO *temp_dinfo;
	struct MYDIRINFO *this_dinfo;
	struct MYDIRINFO *new_dinfo;
	int i = 0, dir_num = -1;

	///* debug code: Viewing behavior of get_newdinfo().
	sprintf(s, "/*** IN FUNCTION get_newdinfo() ***/\n");
	debug_print(s);
	//*/

	// 有効なdinfoを検索/表示する
	for(i=0, temp_dinfo = dinfo; temp_dinfo->this_dir != 0x00000000 ; i++, temp_dinfo++){
		dir_num++;
		this_dinfo = temp_dinfo->this_dir;

		///* debug code: Viewing behavior of get_newdinfo().
		sprintf(s, "dinfo[%d] addr = 0x%08x\n", i, this_dinfo);
		debug_print(s);
		//*/
	}
	///* debug code: Viewing behavior of get_newdinfo().
	sprintf(s, "dinfo[%d]->this_addr = 0x%08x\n", i, temp_dinfo->this_dir);
	debug_print(s);
	this_dinfo = temp_dinfo->this_dir;
	sprintf(s, "max available dir number is %d\n", dir_num);
	debug_print(s);
	sprintf(s, "/*********************************/\n");
	debug_print(s);
	//*/

	/* 新しいディレクトリの初期化 */
	new_dinfo = (dinfo + dir_num + 1);
	sprintf(new_dinfo->name, "");
	new_dinfo->parent_dir = 0;
	new_dinfo->this_dir = 0;

	return new_dinfo;
}

/* ファイルをデータ管理領域からコピーして、コピー先の番地を教える
 * return struct MYFILEDATA: コピー先の番地に格納されているファイルデータ
 * return 0: 失敗
 */
struct MYFILEDATA *myfopen(char *filename, struct MYDIRINFO *dinfo){
	// とりあえずルートディレクトリにあるファイルに対してのみ実行することにする。
	struct MYFILEINFO *finfo = myfinfo_search(filename, dinfo, 224);
	struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;
	unsigned int mem_addr;
	char s[150];
	if(finfo == 0 || (finfo->type & FTYPE_DIR) != 0){
		/* 該当するファイルがROOTディレクトリに存在しなかった場合
		 * または、該当するファイルがディレクトリであった場合 */
		debug_print("In function myfopen(): file was not found.\n");
		return 0;
	}else{
		/* openのときにはSTAT_OPENEDは確認しない (要検討)*/
		finfo->fdata->head.stat |= STAT_OPENED;
		sprintf(s, "fdata = 0x%08x\n[debug] head.data_addr = 0x%08x\n[debug] head.dir_addr = 0x%08x\n[debug] head.stat = 0x%02x\n[debug] body = %s[EOF]\n",
				finfo->fdata,
				finfo->fdata->head.data_addr,
				finfo->fdata->head.dir_addr,
				finfo->fdata->head.stat,
				finfo->fdata->body);
		debug_print(s);

		mem_addr = memman_alloc_4k(memman, sizeof(struct MYFILEDATA)*3); // 12,282byte確保(fdata１２個分)

		unsigned int i;
		struct MYFILEDATA *this_fdata;
		struct MYFILEDATA *prev_fdata;
		prev_fdata = this_fdata = 0;
		for(i=0; i<12; i++){	// 事前に12個分の連結したファイルデータを用意しておく
			prev_fdata = this_fdata;
			this_fdata = (struct MYFILEDATA *)mem_addr;
			this_fdata += i;
			sprintf(s, "this_addr = 0x%08x\n", this_fdata);	// 最初はmem_addrと同じ値
			debug_print(s);

			memcpy(this_fdata, finfo->fdata, sizeof(struct MYFILEDATA));
			sprintf(s, "this_fdata->body = %s[EOF]\n", this_fdata->body);
			debug_print(s);

			// ファイルデータの整形
			if(i==0){					// スタートファイル
				this_fdata->head.stat |= STAT_CONT;

			}else if(1<=i && i<=10){	// 中間ファイル
				this_fdata->head.stat |= STAT_CONT;
				prev_fdata->head.next_data = this_fdata;
				myfwrite(this_fdata, "");	// 中間ファイルは空という前提(要検討)
			}else if(i==11){			// エンドファイル
				this_fdata->head.stat &= (STAT_ALL - STAT_CONT);
				prev_fdata->head.next_data = this_fdata;
				this_fdata->head.next_data = 0;
				myfwrite(this_fdata, "");	// エンドファイルは空という前提(要検討)
			}
		}


		///* debug: コピーしたメモリ管理領域(ここで色々な作業を行う)
		struct MYFILEDATA *fdata = (struct MYFILEDATA *)mem_addr;
		sprintf(s, "allocated fdata addr = 0x%08x\n", fdata);
		debug_print(s);
		//*/
		return (struct MYFILEDATA *)mem_addr;
	}
	return 0;
}

/* データ管理領域の該当ファイルがオープンされていたら、メモリを解放し、status bitのopenedを書き換える。
 * return 0: if success
 * return -1: if failed
 * */
int myfclose(struct MYFILEDATA *opened_fdata){
	// データ領域にある実物のデータをfdataに格納する
	struct MYFILEDATA *fdata =(struct MYFILEDATA *)opened_fdata->head.data_addr;
	struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;
	unsigned char status;
	int i;
	char s[100];	// デバッグ用

	if((fdata->head.stat & STAT_OPENED) == 0){
		/* オープンされていないファイルの場合 */
		debug_print("In function myfclose(): this file data is already closed.\n");
		return -1;	// close失敗
	}else{
		/* オープンされているファイルの場合、ステータス変数を変更する */
		status = opened_fdata->head.stat;	// status変数を作り、読みやすくする
		status = status & (STAT_ALL - STAT_OPENED);	// open bitを折る()
		fdata->head.stat = status;	// データ領域のheadを書き換えるう

		/* メモリの解放 */
		i = memman_free_4k(memman, (unsigned int)opened_fdata, sizeof(struct MYFILEDATA));
		sprintf(s, "return memman_free_4k() = %d\n", i);
		debug_print(s);
		return 0;	// close成功
	}

	return -1;
}

/* データ管理領域の該当ファイルがセーブ可能ならば、fdata->bodyの内容を保存する
 * return 0: success
 * return -1: failed
 */
int myfsave(struct MYFILEDATA *opened_fdata){
	struct MYFILEDATA *fdata = (struct MYFILEDATA *)opened_fdata->head.data_addr;
	char s[1000];
	if((fdata->head.stat & STAT_OPENED) == 0){
		/* オープンされていないファイルに対して保存しようとした場合 */
		sprintf(s, "In function myfsave(): this file data is not opened.\n");
		debug_print(s);
		return -1;	// close失敗
	}else{
		/* ブロックを跨いで保存するときはもっと違うアルゴリズムが必要になる(要検討) */
		myfread(s, opened_fdata);	// バッファからファイルデータを読み込む
		myfwrite(fdata, s);			// 読み込んだファイルデータを書き込む
		return 0;	// close成功
	}

	return -1;	// close失敗
}

/* データ管理領域の使われていない空間を探し、初期化したのち、その場所を教える
 * return 発見したMYFILEDATA
 */
struct MYFILEDATA *get_newfdata(struct MYDIRINFO *dinfo){
	struct MYFILEDATA *root_fdata = (struct MYFILEDATA *) ROOT_DATA_ADDR;
	struct MYFILEDATA *temp_fdata;
	struct MYFILEDATA *new_fdata;
	char s[100];

	sprintf(s, "/*** IN FUNCTION get_newfdata() ***/\n");
	debug_print(s);
	temp_fdata = root_fdata;
	while((temp_fdata->head.stat & STAT_VALID) != 0){
		sprintf(s, "temp_fdata addr = 0x%08x\n", temp_fdata);
		debug_print(s);
		temp_fdata += 1; // 隣の番地に移動
	}
	/* valid bitが0のfile dataが見つかった */
	new_fdata = temp_fdata;
	sprintf(s, "invalid temp_fdata addr = 0x%08x\n", new_fdata);
	debug_print(s);

	/* ファイルデータの初期化 */
	sprintf(new_fdata->body, "");		// データの初期化
	new_fdata->head.stat = STAT_VALID;	// 初期ステータスはvalidのみ立っている状態
	new_fdata->head.data_addr = (unsigned int *)new_fdata;	// 自分の本来の番地を記憶(open時に必要)
	new_fdata->head.dir_addr = (unsigned int *)dinfo->this_dir;
	new_fdata->head.next_data = 0;		// 番兵として使う

	sprintf(s, "/********************************/\n");
	debug_print(s);

	return new_fdata;
}

/**
 * interface to write data into file
 * @param body: string data to be written
 * @param str: string data to write
 * return 1: succeeded
 * return 0: failed
 * [注意！]一文字単位で修正する関数も用意する必要がある(INSERT MODE用)
 */
#define TEST_SIZE 10
int myfwrite(struct MYFILEDATA *fdata, char *str){
	char s[100];
	int i,j;
	int block_count = 1;
	struct MYFILEDATA *test_fdata;
	sprintf(s, "myfwrite() has been called.\n");
	debug_print(s);

	sprintf(s, "str = %s[EOF]\n", str);
	debug_print(s);

	i=0;
	j=0;
	while(str[i] != '\0'){
		fdata->body[j] = str[i];
		i++;
		j++;
		if(i == TEST_SIZE * block_count){
			test_fdata = fdata;
			fdata++;
			block_count++;
			sprintf(s, "block moved: 0x%08x -> 0x%08x\n", test_fdata, fdata);
			debug_print(s);
			j=0;
		}
	}


	// sprintf(fdata->body, str);
	//sprintf(s, "%d/%d is used.\n", get_size_myfdata(fdata), BLOCK_SIZE);
	//debug_print(s);
	return 1;
}

/**
 * interface to read data from file
 * @param str: string data to read
 * @param body: string data to be read
 * return 1: succeeded
 * return 0: failed
 */
int myfread(char *str, struct MYFILEDATA *fdata){
	char s[50];
	int i=0;
	sprintf(s, "myfread() has been called.\n");
	debug_print(s);
	sprintf(str, "");	// strの初期化

	while((fdata->head.stat & STAT_CONT) != 0){
		sprintf(s, "fdata->body[%d] = %s[EOF]\n", i, fdata->body);
		i++;
		debug_print(s);
		strcat(str, fdata->body);
		fdata = fdata->head.next_data;
	}

	sprintf(s, "str = %s[EOF]\n", str);
	debug_print(s);
	return 1;
}

/**
 * calculate size of file data, and return a result[byte].
 * @param fdata: file data
 */
int get_size_myfdata(struct MYFILEDATA *fdata){
	int p;
	p=0;
	while(fdata->body[p] != '\0') p++;
	return p;	// 単位はバイト
}

/**
 * calculate size of char*, and return a result[byte].
 * @param fdata: char *
 */
int get_size_char(char *str){
	int p;
	p=0;
	while(str[p] != '\0') p++;
	return p;	// 単位はバイト
}
